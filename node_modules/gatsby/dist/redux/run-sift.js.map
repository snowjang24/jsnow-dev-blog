{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["default","sift","require","_","prepareRegex","makeRe","getValueAt","toDottedFields","objectToDottedField","liftResolvedFields","prepareQueryArgs","filterFields","Object","keys","reduce","acc","key","value","isPlainObject","getFilters","filters","push","isEqId","firstOnly","siftArgs","length","id","handleFirst","nodes","index","isEmpty","findIndex","$and","handleMany","sort","resolvedFields","result","filter","dottedFields","dottedFieldKeys","sortFields","fields","map","field","some","startsWith","v","sortOrder","order","toLowerCase","orderBy","runSift","args","getNode","getNodesAndResolvedNodes","nodeTypeNames","typeName","runSiftOnNodes","exports","queryArgs","siftFilter","node","internal","includes","type"],"mappings":"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","sourcesContent":["// @flow\nconst { default: sift } = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst { makeRe } = require(`micromatch`)\nconst { getValueAt } = require(`../utils/get-value-at`)\nconst {\n  toDottedFields,\n  objectToDottedField,\n  liftResolvedFields,\n} = require(`../db/common/query`)\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nconst prepareQueryArgs = (filterFields = {}) =>\n  Object.keys(filterFields).reduce((acc, key) => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      acc[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(value)\n    } else {\n      switch (key) {\n        case `regex`:\n          acc[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          acc[`$regex`] = makeRe(value)\n          break\n        default:\n          acc[`$${key}`] = value\n      }\n    }\n    return acc\n  }, {})\n\nconst getFilters = filters =>\n  Object.keys(filters).reduce(\n    (acc, key) => acc.push({ [key]: filters[key] }) && acc,\n    []\n  )\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(firstOnly, siftArgs) {\n  return (\n    firstOnly &&\n    siftArgs.length > 0 &&\n    siftArgs[0].id &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : nodes.findIndex(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort, resolvedFields) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : nodes.filter(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort) {\n    // create functions that return the item to compare on\n    const dottedFields = objectToDottedField(resolvedFields)\n    const dottedFieldKeys = Object.keys(dottedFields)\n    const sortFields = sort.fields\n      .map(field => {\n        if (\n          dottedFields[field] ||\n          dottedFieldKeys.some(key => field.startsWith(key))\n        ) {\n          return `__gatsby_resolved.${field}`\n        } else {\n          return field\n        }\n      })\n      .map(field => v => getValueAt(v, field))\n    const sortOrder = sort.order.map(order => order.toLowerCase())\n\n    result = _.orderBy(result, sortFields, sortOrder)\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nconst runSift = (args: Object) => {\n  const { getNode, getNodesAndResolvedNodes } = require(`./nodes`)\n\n  const { nodeTypeNames } = args\n\n  let nodes\n\n  if (nodeTypeNames.length > 1) {\n    nodes = nodeTypeNames.reduce((acc, typeName) => {\n      acc.push(...getNodesAndResolvedNodes(typeName))\n      return acc\n    }, [])\n  } else {\n    nodes = getNodesAndResolvedNodes(nodeTypeNames[0])\n  }\n\n  return runSiftOnNodes(nodes, args, getNode)\n}\n\nexports.runSift = runSift\n\nconst runSiftOnNodes = (nodes, args, getNode) => {\n  const {\n    queryArgs = { filter: {}, sort: {} },\n    firstOnly = false,\n    resolvedFields = {},\n    nodeTypeNames,\n  } = args\n\n  let siftFilter = getFilters(\n    liftResolvedFields(\n      toDottedFields(prepareQueryArgs(queryArgs.filter)),\n      resolvedFields\n    )\n  )\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(firstOnly, siftFilter)) {\n    const node = getNode(siftFilter[0].id[`$eq`])\n\n    if (\n      !node ||\n      (node.internal && !nodeTypeNames.includes(node.internal.type))\n    ) {\n      return []\n    }\n\n    return [node]\n  }\n\n  if (firstOnly) {\n    return handleFirst(siftFilter, nodes)\n  } else {\n    return handleMany(siftFilter, nodes, queryArgs.sort, resolvedFields)\n  }\n}\n\nexports.runSiftOnNodes = runSiftOnNodes\n"],"file":"run-sift.js"}