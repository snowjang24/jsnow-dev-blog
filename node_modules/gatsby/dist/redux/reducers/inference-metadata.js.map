{"version":3,"sources":["../../../src/redux/reducers/inference-metadata.js"],"names":["omit","require","addNode","addNodes","deleteNode","ignore","disable","NodeInterfaceFields","typesWithoutInference","StepsEnum","initialBuild","incrementalBuild","initialState","step","typeMap","module","exports","state","action","type","incrementalReducer","ignoredFields","Set","initialTypeMetadata","typeDefs","Array","isArray","payload","ignoredTypes","reduce","forEach","nodes","typeName","types","node","oldNode","internal","addedField","previousFields","fields","dirty","fullNodes","Object","keys"],"mappings":"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","sourcesContent":["// Tracking structure of nodes to utilize this metadata for schema inference\n// Type descriptors stay relevant at any point in time making incremental inference trivial\nconst { omit } = require(`lodash`)\nconst {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n} = require(`../../schema/infer/inference-metadata`)\nconst { NodeInterfaceFields } = require(`../../schema/types/node-interface`)\nconst { typesWithoutInference } = require(`../../schema/types/type-defs`)\n\nconst StepsEnum = {\n  initialBuild: `initialBuild`,\n  incrementalBuild: `incrementalBuild`,\n}\n\nconst initialState = () => {\n  return {\n    step: StepsEnum.initialBuild, // `initialBuild` | `incrementalBuild`\n    typeMap: {},\n  }\n}\n\nmodule.exports = (state = initialState(), action) => {\n  switch (action.type) {\n    case `CREATE_NODE`:\n    case `DELETE_NODE`:\n    case `DELETE_NODES`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n    case `ADD_FIELD_TO_NODE`: {\n      // Perf: disable incremental inference until the first schema build.\n      // There are plugins which create and delete lots of nodes during bootstrap,\n      // which makes this reducer to do a lot of unnecessary work.\n      // Instead we defer the initial metadata creation until the first schema build\n      // and then enable incremental updates explicitly\n      if (state.step === StepsEnum.initialBuild) {\n        return state\n      }\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n\n    case `START_INCREMENTAL_INFERENCE`: {\n      return {\n        ...state,\n        step: StepsEnum.incrementalBuild,\n      }\n    }\n\n    case `DELETE_CACHE`: {\n      return initialState()\n    }\n\n    default: {\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n  }\n}\n\nconst ignoredFields = new Set([\n  ...NodeInterfaceFields,\n  `$loki`,\n  `__gatsby_resolved`,\n])\n\nconst initialTypeMetadata = () => {\n  return { ignoredFields }\n}\n\nconst incrementalReducer = (state = {}, action) => {\n  switch (action.type) {\n    case `CREATE_TYPES`: {\n      const typeDefs = Array.isArray(action.payload)\n        ? action.payload\n        : [action.payload]\n      const ignoredTypes = typeDefs.reduce(typesWithoutInference, [])\n      ignoredTypes.forEach(type => {\n        state[type] = ignore(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `BUILD_TYPE_METADATA`: {\n      // Overwrites existing metadata\n      const { nodes, typeName } = action.payload\n      state[typeName] = addNodes(initialTypeMetadata(), nodes)\n      return state\n    }\n\n    case `DISABLE_TYPE_INFERENCE`: {\n      // Note: types disabled here will be re-enabled after BUILD_TYPE_METADATA\n      const types = action.payload\n      types.forEach(type => {\n        state[type] = disable(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `CREATE_NODE`: {\n      const { payload: node, oldNode } = action\n      const { type } = node.internal\n      if (oldNode) {\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), oldNode)\n      }\n      state[type] = addNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) return state\n      const { type } = node.internal\n      state[type] = deleteNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `ADD_FIELD_TO_NODE`: {\n      const { payload: node, addedField } = action\n      const { type } = node.internal\n\n      // Must unregister previous fields first.\n      // Can't simply add { fields: { [addedField]: node.fields[addedField] } }\n      // because it will count `fields` key twice for the same node\n      const previousFields = omit(node.fields, [addedField])\n      state[type] = deleteNode(state[type], { fields: previousFields })\n      state[type] = addNode(state[type], { fields: node.fields })\n\n      // TODO: there might be an edge case when the same field is \"added\" twice.\n      //   Then we'll count it twice in metadata. The only way to avoid it as I see it\n      //   is to pass original node before modifications along with a new node\n      //   in action payload and utilize original `node.fields` in deleteNode call above\n      return state\n    }\n\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`: {\n      // Marking parent type as dirty so that it rebuilds\n      const { type } = action.payload.internal\n      state[type].dirty = true\n      return state\n    }\n\n    // Deprecated, will be removed in Gatsby v3.\n    case `DELETE_NODES`: {\n      const { fullNodes } = action\n      fullNodes.forEach(node => {\n        const { type } = node.internal\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), node)\n      })\n      return state\n    }\n\n    case `SET_SCHEMA`: {\n      Object.keys(state).forEach(type => {\n        state[type].dirty = false\n      })\n      return state\n    }\n\n    default:\n      return state\n  }\n}\n"],"file":"inference-metadata.js"}