{"version":3,"sources":["../../src/query/queue.js"],"names":["Queue","require","store","FastMemoryStore","queryRunner","websocketManager","GraphQLRunner","createBaseOptions","concurrent","createBuildQueue","graphqlRunner","handler","queryJob","callback","then","result","catch","createDevelopQueue","getRunner","queue","processing","Set","waiting","Map","queueOptions","priority","job","cb","id","activePaths","has","merge","oldTask","newTask","filter","set","isPage","emitPageData","emitStaticQueryData","delete","push","get","error","pushJob","Promise","resolve","reject","on","processBatch","jobs","activity","numJobs","length","runningJobs","map","v","tick","all","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\nconst { store } = require(`../redux`)\nconst FastMemoryStore = require(`../query/better-queue-custom-store`)\nconst queryRunner = require(`../query/query-runner`)\nconst websocketManager = require(`../utils/websocket-manager`)\nconst GraphQLRunner = require(`./graphql-runner`)\n\nconst createBaseOptions = () => {\n  return {\n    concurrent: 4,\n    store: FastMemoryStore(),\n  }\n}\n\nconst createBuildQueue = () => {\n  const graphqlRunner = new GraphQLRunner(store)\n  const handler = (queryJob, callback) =>\n    queryRunner(graphqlRunner, queryJob)\n      .then(result => callback(null, result))\n      .catch(callback)\n  return new Queue(handler, createBaseOptions())\n}\n\nconst createDevelopQueue = getRunner => {\n  let queue\n  const processing = new Set()\n  const waiting = new Map()\n\n  const queueOptions = {\n    ...createBaseOptions(),\n    priority: (job, cb) => {\n      if (job.id && websocketManager.activePaths.has(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n    // Filter out new query jobs if that query is already running.\n    // When the query finshes, it checks the waiting map and pushes\n    // another job to make sure all the user changes are captured.\n    filter: (job, cb) => {\n      if (processing.has(job.id)) {\n        waiting.set(job.id, job)\n        cb(`already running`)\n      } else {\n        cb(null, job)\n      }\n    },\n  }\n\n  const handler = (queryJob, callback) => {\n    queryRunner(getRunner(), queryJob).then(\n      result => {\n        if (queryJob.isPage) {\n          websocketManager.emitPageData({\n            result,\n            id: queryJob.id,\n          })\n        } else {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.id,\n          })\n        }\n\n        processing.delete(queryJob.id)\n        if (waiting.has(queryJob.id)) {\n          queue.push(waiting.get(queryJob.id))\n          waiting.delete(queryJob.id)\n        }\n        callback(null, result)\n      },\n      error => callback(error)\n    )\n  }\n\n  queue = new Queue(handler, queueOptions)\n  return queue\n}\n\nconst pushJob = (queue, job) =>\n  new Promise((resolve, reject) =>\n    queue\n      .push(job)\n      .on(`finish`, resolve)\n      .on(`failed`, reject)\n  )\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n */\nconst processBatch = async (queue, jobs, activity) => {\n  let numJobs = jobs.length\n  if (numJobs === 0) {\n    return Promise.resolve()\n  }\n\n  const runningJobs = jobs.map(job =>\n    pushJob(queue, job).then(v => {\n      if (activity.tick) {\n        activity.tick()\n      }\n      return v\n    })\n  )\n  return Promise.all(runningJobs)\n}\n\nmodule.exports = {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n}\n"],"file":"queue.js"}